# lambda表达式的基础
我们定义一个lambda表达式，可以看作是一种描述匿名函数的简单形式。我知道这句话信息量太大，所以，我们将通过一些现有的Java代码示例来解释lambda表达式。Swing是一个用来写图形用户界面（GUI）的平台无关Java库。它采用了一个相当普遍的风格：你需要注册一个事件监听，来发现你的用户做了什么。事件监听可以执行一些动作来回应用户的输入行为。（看代码1-1）

_Example 1-1. 使用一个匿名内部类来将行为和一个点击按钮联系起来。_
```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
        System.out.println("button clicked");
    }
});
```

在这个例子中，我们创建一个实现了**ActionListener**类的实例对象。这个接口有一个单一方法，**actionPerformed**，当用户真实点击屏幕上的按钮时这个方法会被**按钮**实例所执行。该匿名内部类提供了方法的实现。在Example1-1中，它所做的就是当按钮被点击时打印一条信息。

> 这是一个_行为参数化_的实际例子——我们为按钮提供乐一个封装行为的对象。  

匿名内部类被设计用来为Java开发者方便地提供并传入行为。不幸的是，它们的设计不够简单。一行主要逻辑代码，却需要提供四行无关的模板代码。
模板代码不是唯一的问题：这些代码非常难于阅读，因为它复杂化了开发者的意图。我们不想在对象上花心思，行为才是我们真正需要去注意的。在Java 8 中，我们使用一个lambda表达式来写这个例子，如Example 1-2所示。

_Example 1-2. 使用lambda表达式_
```java
button.addActionListener(event -> System.out.println("button clicked"));
```


作为实现接口的对象的替代，我们传入一个代码块——匿名函数。和在匿名内部类例子中的参数一样，**event**是一个参数的名字。-> 将lambda表达式的参数和函数体分开，函数体就是一些当用户点击我们的按钮时会运行的代码。
该例和匿名内部类另一个不同的地方是我们怎么声明这个**event**参数？之前，我们需要明确提供**event**类型——**ActionEvent** 。在这个例子中，我们没有提供这个类型，这个例子却仍然编译成功了。编译器做了些什么？**javac**通过上下文推断出**event**变量的类型——从**addActionListener**的函数签名上。这意味着当类型显而易见时，你不需要明确地写出类型。我们过会儿再具体讨论着种推断行为，现在先让我们看看编写lambda表达式的不同方式。

> 相比较之前，虽然lambda方法参数需要更少的模板代码，但它们仍然是静态类型。为了可读性和友好性，你还可以包含类型声明，而且有的时候编译器也会无法推断类型。  
