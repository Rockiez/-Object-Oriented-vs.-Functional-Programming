# lambda表达式的基础

我们将会定义一个lambda表达式，可以看作是描述一个匿名函数的简单方式。我知道有很多东西需要一次解决，所以，我们将通过一些现有的Java代码示例来解释lambda表达式。Swing是一个用来写图形用户界面（GUI）的平台无关Java库。它采用了一个相当普遍的风格：为了发现你的用户做了什么，你需要注册一个事件监听。这个事件监听可以在运行一些动作来对用户的输入作出反应。（看代码1-1）

/Example 1-1. 使用一个匿名内部类来将行为和一个点击按钮联系起来。/
```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
        System.out.println("button clicked");
    }
});
```

在这个例子中，我们创建一个实现了*ActionListener*类的实例对象。这个接口有唯一一个方法，*actionPerformed*，当用户真实点击屏幕上的按钮时这个方法会被*按钮*实例执行。这个匿名内部类提供了方法的实现。在Example1-1中，它所做的就是打印一条信息以示按钮被点击了。

> 这是一个/行为参数化/的实际例子——我们提供给按钮一个封装了行为的对象。

匿名内部类被设计用来为Java开发者方便地提供或者忽略行为。不幸的是，它们被设计的还不够简单。只是一行主要的逻辑代码，却需要提供四行无关的模板代码。
冗余的模板代码不是唯一的问题，而且这些代码非常难于阅读，因为它复杂化了开发者的意图。我们不想在对象上花心思，行为才是我们真正需要去注意的。在Java 8 中，我们使用一个lambda表达式来写这个例子，如Example 1-2所示。
/Example 1-2. 使用一个lambda表达式/
```java
button.addActionListener(event -> System.out.println("button clicked"));
```

不再使用一个实现了接口的对象，我们使用了一个代码块——一个没有名字的函数。*事件* 是一个参数的名字，和在匿名内部类例子中的参数一样，-> 将lambda表达式的参数和函数体分开，函数体就是一些当用户点击我们的按钮时会运行的代码。
该例和匿名内部类另一个不同的地方是我们怎么声明这个*事件*变量？之前，我们需要明确提供它的类型——*ActionEvent* *事件*。在这个例子中，我们根本没有提供这个类型，这个例子却仍然编译成功了。小树林里到底藏了什么小秘密？*javac* 通过上下文推断出*事件*变量的类型——从*addActionListener*的函数签名上。这意味着当类型显而易见时，你不需要明确地写出类型。我们过会儿再具体讨论着种推断行为，现在先让我们看看编写lambda表达式的不同方式。

> 相比较之前，虽然lambda方法参数需要更少的模板代码，但它们仍然是静态类型。为了可读性和友好型，你还可以包含类型声明，有的时候编译器也会无法推断类型。
